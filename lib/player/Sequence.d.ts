import { VoiceLeadingOptions } from '../harmony/Voicing';
import { SheetState } from '../sheet/Sheet';
import { Measure, RenderedMeasure, Measures } from '../sheet/Measure';
import { Leadsheet } from './Leadsheet';
import { RhythmEvent } from '../rhythmical/Rhythm';
export interface SequenceEvent extends RhythmEvent<any> {
    path: number[];
    value: any;
    chord?: string;
    color?: string;
    divisions?: number[];
    fraction?: number;
    duration?: number;
    velocity?: number;
    time?: number;
    type?: string;
    options?: SequenceOptions;
    measure?: RenderedMeasure<any>;
}
export declare type Groove = {
    [name: string]: (events: SequenceEvent[], options: SequenceOptions) => SequenceEvent[];
};
export declare type GroovePresetOptions = {
    target?: SequenceEvent;
    source?: SequenceEvent;
    grooveEvents?: SequenceEvent[];
    sourceEvents?: SequenceEvent[];
    options?: SequenceOptions;
    index?: number;
};
export declare type GroovePreset = (options: GroovePresetOptions) => SequenceEvent;
export declare type EventModifier = (event: SequenceEvent, index: number, events: SequenceEvent[], options: SequenceOptions) => SequenceEvent;
export declare type EventFactory<T> = (options?: SequenceOptions) => T;
export declare type EventMapFn = (event: SequenceEvent, index?: number, events?: SequenceEvent[]) => SequenceEvent;
export declare type EventMap = EventFactory<EventMapFn>;
export declare type EventReduceFn = (events: SequenceEvent[], event: SequenceEvent, index?: number, originalEvents?: SequenceEvent[]) => SequenceEvent[];
export declare type EventReduce = EventFactory<EventReduceFn>;
export declare type EventFilterFn = (event: SequenceEvent, index?: number, events?: SequenceEvent[]) => boolean;
export declare type EventFilter = EventFactory<EventFilterFn>;
export interface SequenceOptions extends SheetState<any> {
    logging?: boolean;
    arpeggio?: boolean;
    pedal?: boolean;
    tightMelody?: boolean;
    real?: boolean;
    fermataLength?: number;
    start?: number;
    swing?: number;
    offsPlayNext?: boolean;
    swingSubdivision?: string;
    dynamicVelocityRange?: number[];
    dynamicVelocity?: EventModifier;
    phantomMelody?: boolean;
    humanize?: {
        velocity?: number;
        time?: number;
        duration?: number;
    };
    groove?: Groove;
    voicings?: VoiceLeadingOptions;
    feel?: number;
    pulses?: number;
    bpm?: number;
    filterEvents?: EventFilterFn;
    mapEvents?: EventMapFn;
    reduceEvents?: EventReduceFn;
    displaceChance?: number;
    displaceTime?: number;
    displaceDuration?: number;
}
export declare class Sequence {
    static getSignType(symbol: string): string;
    static getOptions(options: SequenceOptions): {
        logging?: boolean;
        arpeggio?: boolean;
        pedal?: boolean;
        tightMelody?: boolean;
        real?: boolean;
        fermataLength?: number;
        start?: number;
        swing?: number;
        offsPlayNext?: boolean;
        swingSubdivision?: string;
        dynamicVelocityRange?: number[];
        dynamicVelocity?: EventModifier;
        phantomMelody?: boolean;
        humanize?: {
            velocity?: number;
            time?: number;
            duration?: number;
        };
        groove?: Groove;
        voicings?: VoiceLeadingOptions;
        feel?: number;
        pulses?: number;
        bpm: number;
        filterEvents?: EventFilterFn;
        mapEvents?: EventMapFn;
        reduceEvents?: EventReduceFn;
        displaceChance?: number;
        displaceTime?: number;
        displaceDuration?: number;
        measures?: RenderedMeasure<any>[];
        index?: number;
        sheet?: any[];
        jumps?: {
            [key: number]: number;
        };
        visits?: {
            [key: number]: number;
        };
        nested?: boolean;
        fallbackToZero?: boolean;
        forms?: number;
        totalForms?: number;
        firstTime?: boolean;
        lastTime?: boolean;
    };
    static testEvents: (props: string[]) => (event: any) => any;
    static addLatestOptions: EventReduce;
    static addTimeAndDuration: EventReduce;
    static pedalNotes: EventReduce;
    static prolongNotes: EventReduce;
    static renderVoicings: EventReduce;
    static addFermataToEnd: EventMap;
    static renderBass: EventReduce;
    static isBefore(a: SequenceEvent, b: SequenceEvent): boolean;
    static isAfter(a: SequenceEvent, b: SequenceEvent): boolean;
    static isOverlapping(a: SequenceEvent, b: SequenceEvent): boolean;
    static isTouching(a: SequenceEvent, b: SequenceEvent): boolean;
    static isInside(a: SequenceEvent, b: SequenceEvent): boolean;
    static duckChordEvent: EventMap;
    static humanizeEvent: EventMap;
    static velocityFromIndex: EventMap;
    static velocityFromPitch: EventMap;
    static addDynamicVelocity: EventMap;
    static isOff(event: any): boolean;
    static addSwing: EventReduce;
    static inOut: EventFilter;
    static removeDuplicates: EventFilter;
    static renderGrid(measures: Measures<any>, options?: SequenceOptions): SequenceEvent[];
    static renderMeasures(measures: Measures<any>, options?: SequenceOptions): SequenceEvent[];
    static getNextChordOff: GroovePreset;
    static fillGrooves(groove: Measure<any> | (() => Measures<any>), sourceEvents: SequenceEvent[], mapFn?: GroovePreset, options?: SequenceOptions): SequenceEvent[];
    static insertGrooves(groove: Measures<any> | ((source: SequenceEvent, events: SequenceEvent[]) => Measures<any>), sourceEvents: SequenceEvent[], mergeFn?: GroovePreset, options?: SequenceOptions): SequenceEvent[];
    static melodyGroove(): ({ target, source, index, grooveEvents }: {
        target: any;
        source: any;
        index: any;
        grooveEvents: any;
    }) => any;
    static chordGroove(): GroovePreset;
    static renderEvents(events: SequenceEvent[], options?: SequenceOptions): SequenceEvent[];
    static renderGroove(sequence: SequenceEvent[], options: SequenceOptions): any[];
    static insertBassNote: any;
    static render(sheet: Leadsheet): SequenceEvent[];
}
