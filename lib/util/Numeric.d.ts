declare type ExitCase = (value: number, sequence: number[]) => boolean;
declare type NumericOptions = {
    exitCase?: ExitCase;
    initialValues?: number[];
    plotRange?: number[];
    quantization?: number;
    plotFunction?: PlotFunction;
    sequenceFunction?: SequenceFunction;
};
declare type PlotFunction = (x: number) => number;
declare type SequenceFunction = (sequence: number[], index: number) => number;
declare type SequencePoint = (sequence: number[], index: number) => number;
export declare class Numeric {
    static sequence(f: any, options?: NumericOptions): any[];
    static minMax(...values: any[]): any[];
    static api(options: NumericOptions): {
        init: (values: any) => any;
        range: (a: number, b: number) => any;
        fixed: (length: number) => any;
        sequence: (f: SequencePoint) => any[];
        plot: (f: PlotFunction) => any;
        render: () => any[];
        exitCase?: ExitCase;
        initialValues?: number[];
        plotRange: number[];
        quantization: number;
        plotFunction?: PlotFunction;
        sequenceFunction?: SequenceFunction;
        inititialValues: any[];
    };
    static init(initialValues: number[] | number): {
        init: (values: any) => any;
        range: (a: number, b: number) => any;
        fixed: (length: number) => any;
        sequence: (f: SequencePoint) => any[];
        plot: (f: PlotFunction) => any;
        render: () => any[];
        exitCase?: ExitCase;
        initialValues?: number[];
        plotRange: number[];
        quantization: number;
        plotFunction?: PlotFunction;
        sequenceFunction?: SequenceFunction;
        inititialValues: any[];
    };
    static range(a: number, b: number, grain?: number): {
        init: (values: any) => any;
        range: (a: number, b: number) => any;
        fixed: (length: number) => any;
        sequence: (f: SequencePoint) => any[];
        plot: (f: PlotFunction) => any;
        render: () => any[];
        exitCase?: ExitCase;
        initialValues?: number[];
        plotRange: number[];
        quantization: number;
        plotFunction?: PlotFunction;
        sequenceFunction?: SequenceFunction;
        inititialValues: any[];
    };
    static fixed(length: number): {
        init: (values: any) => any;
        range: (a: number, b: number) => any;
        fixed: (length: number) => any;
        sequence: (f: SequencePoint) => any[];
        plot: (f: PlotFunction) => any;
        render: () => any[];
        exitCase?: ExitCase;
        initialValues?: number[];
        plotRange: number[];
        quantization: number;
        plotFunction?: PlotFunction;
        sequenceFunction?: SequenceFunction;
        inititialValues: any[];
    };
    static rangeSequence(f: any, [a, b]: [any, any], initialValues?: any[]): any[];
    static fixedSequence(f: any, length: any, initialValues?: any[]): any[];
    static uniqueSequence(f: any, initialValues?: any[]): any[];
    static fibonacci(n: any): any;
    static modRange(number: any, [min, max]: [any, any]): any;
    static saw(range: number[] | number, step?: number): SequencePoint;
    static triangle([min, max]: [any, any], step?: number): (s: any, i: any) => any;
    static square([min, max]: [any, any]): (s: any, i: any) => any;
    static plot(f: PlotFunction): {
        init: (values: any) => any;
        range: (a: number, b: number) => any;
        fixed: (length: number) => any;
        sequence: (f: SequencePoint) => any[];
        plot: (f: PlotFunction) => any;
        render: () => any[];
        exitCase?: ExitCase;
        initialValues?: number[];
        plotRange: number[];
        quantization: number;
        plotFunction?: PlotFunction;
        sequenceFunction?: SequenceFunction;
        inititialValues: any[];
    };
    static plotArray(f: any, range: any, quantization?: number): any[];
    static plotSaw([m, b, mod]: [any, any, any], firstY?: number, length?: any): any[];
    static plotPenrose([min, max]: [any, any], start?: any, step?: number, length?: number): any[];
}
export {};
